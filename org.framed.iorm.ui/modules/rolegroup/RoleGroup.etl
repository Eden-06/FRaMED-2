import "../CardinalityParser.eol";

/*
 * The abstract rule for role groups executes all actions done for all role groups with and without 
 * occurrence constraints.
 */
@abstract 
rule RoleGroup
	transform s : source!Shape
	to t : target!RoleGroup {	
		guard : s.getType==(source!Type#RoleGroup) and
				s.~features.get("Group_Constraints") //feature Group_Constraints implies feature Role_Constraints (not to check)
		
		//set the transformed target element to ensure the subrule work on the same target and only transform once
 		if(s.~transformed == null) {
	 		s.~transformed = t;
			//set name 
			if(s.name.indexOf("(")>-1) {
				s.~transformed.name = s.name.substring(0,s.name.indexOf("(")).trim();
			} else {
				s.~transformed.name = s.name;
			}
			//group constraint
			var desc = s.name;
			if (not (desc == null)) {
				var cards = parseCardinality(desc);
				if(cards.size()>0) {
					t.lower = cards[0];
				}
				if(cards.size()>1) {
					t.upper = cards[1];
				}
			} 
			//transform children
			var children = s.`model`;
			if (not (children == null)) {
				for (elem : source!ModelElement in children.elements) {
					//propagate the features list to all children 
					elem.~features = s.~features;
					//transform the role groups elements
					var e = elem.equivalent();
					if (e.instanceOf(target!RoleGroupElement)) {
						s.~transformed.getElements().add(e);				
					} else {
						if(e.instanceOf(target!Relation)) {
							var compTypeFound = false;
							var compType = s;
							while(not(compTypeFound)) {
								compType = compType.eContainer();
								compTypeFound = not(compType.instanceOf(source!Model)) and compType.getType==(source!Type#CompartmentType);
							}
							if(e.instanceOf(target!Constraint)) {
								compType.equivalent().getConstraints().add(e);
							} else {
								compType.equivalent().getRelationships().add(e);
							}
						} else {
							fail("The element " + elem.getName() + " could not be transformed in the role group " + s.getName() + "!");
		}	}	}	}	}		
}

import "Type.etl";
import "CardinalityParser.eol";

//creates a set used for iorm shapes later in the rule
pre CompartmentType {
	var compartmentTypes : OrderedSet(source!Shape);
}

/**
 * Transforms a shape with type COMPARTMENT_TYPE.
 */
@lazy 
rule CompartmentType
	transform s : source!Shape
	to t : target!CompartmentType {
	guard : s.getType==(source!Type#CompartmentType) 

	compartmentTypes.add(s);
	var children = s.getModel();
	if (not (children == null)) {
		for(e in children.elements) e.~features=s.~features;
	
		// iterate over all children of the compartment type	
		for (elem : source!ModelElement in children.elements) {
		
			var e = elem.equivalent();
			
			if (e == null) { continue; }
			if (e.instanceOf(target!AbstractRole)) { 			// ROLE
				// create a new part with the role
				var part = new target!Part;
				part.role = e;
				part.whole = t;
				// parse the lower and upper bound from the role
				var desc = elem.description;
				if (not (desc == null) and s.~features.get("Occurrence_Constraints")) {
					var card = desc.name;
					var cards = parseCardinality(card);
					
					if(cards.size()>0) {
						part.lower = cards[0];
						if(cards.size()>1) {
							part.upper = cards[1];
						}				
					}	
				}				
				// add the new part to the compartment
				t.getParts().add(part);
			} else if (e.instanceOf(target!CompartmentType)) {	//COMPARTMENT_TYPE
				t.getContains.add(e);
				if(not(s.~features.get("Contains_Compartments"))) t.getContains.remove(e);
			} else if (e.instanceOf(target!RelationshipImplication) or e.instanceOf(target!RelationshipExclusion)) { // INTER_RELATIONSHIP_CONSTRAINT
				t.getConstraints().add(e);				
			} else if ( e.instanceOf(target!Constraint)) {		// CONSTRAINT
				t.getConstraints().add(e);
			} else if ( e.instanceOf(target!Relationship)) {	// RELATIONSHIP
				t.getRelationships().add(e);
			} else if ( e.instanceOf(target!RoleInheritance)) { //INHERITANCE
				s.~parent.relations.add(e);
			} else if ( e.instanceOf(Sequence(target!Fulfillment))) {		//FULFILLMENT
				for(ob in e) {	
					t.getFulfillments.add(ob);
				}	
			}
		}
	}
	
	t.name = s.name;
}

/**
 * Add operations and attributes in the post processing step.
 *
 * This separation is necessary as the type references in attributes and operations may form cycles between
 * types/shapes. The post block ensures that these cycles can be resolved.
 */
post CompartmentType {
	for (s : source!Shape in compartmentTypes) {
		var t = s.equivalent();

		if (not t.isDefined() or not s.isDefined()) {
			continue;
		}

		if(s.~features.get("Compartment_Behavior")) { //feature Compartment_Behavior implies feature Compartment_Properties (not to check)
			s.addAttributes(t);
		    s.addOperations(t);
		}	
	}
}

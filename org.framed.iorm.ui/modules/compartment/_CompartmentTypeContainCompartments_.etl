import "CompartmentTypeAttsAndOps.etl";

/**
 * This rule transforms a compartment which can not contain other compartment types.
 * 
 * This particular rule only transforms compartment when also its attributes and operations
 * are enabled. This is needed since using the multiple extension 
 * "extends CompartmentTypeWithAttAndOps, CompartmentTypeWithoutAttAndOps" somehow creates a cycle 
 * extension. Thats why there need to be two separate rule for compartment which can not contain 
 * other compartment types.
 */
@lazy
rule CompartmentTypeCannotContainCompartments_1
	transform s : source!Shape
	to t : target!CompartmentType 
	extends CompartmentTypeWithAttAndOps {
		guard : not(s.~features.get("Contains_Compartments"))
 		
 		cannotContainCompartment(s);
}

/**
 * This rule transforms a compartment which can not contain other compartment types.
 * 
 * This particular rule only transforms compartment when also its attributes and operations
 * are not enabled. This is needed since using the multiple extension 
 * "extends CompartmentTypeWithAttAndOps, CompartmentTypeWithoutAttAndOps" somehow creates a cycle 
 * extension. Thats why there need to be two separate rule for compartment which can not contain
 * other compartment types.
 */
@lazy
rule CompartmentTypeCannotContainCompartments_2
	transform s : source!Shape
	to t : target!CompartmentType 
	extends CompartmentTypeWithoutAttAndOps {
		guard : not(s.~features.get("Contains_Compartments"))
 		
 		cannotContainCompartment(s);
}

/**
 * the actions to execute when a compartment can not contain other compartments
 */
operation cannotContainCompartment(s : source!Shape) {
	if(not(s.getModel() == null)) {
 		for (elem : source!ModelElement in s.getModel().elements) {	
			//if the children is another compartment type
			if(elem.getType==(source!Type#CompartmentType)) {
				var e = elem.equivalent();
				if(not(e == null)) {
					delete(e);
	}	}	}	}
}

/**
 * This rule transforms a compartment which can contain other compartment types.
 * 
 * This particular rule only transforms compartment when also its attributes and operations
 * are enabled. This is needed since using the multiple extension 
 * "extends CompartmentTypeWithAttAndOps, CompartmentTypeWithoutAttAndOps" somehow creates a cycle 
 * extension. Thats why there need to be two separate rule for compartment which can contain 
 * other compartment types.
 */
@lazy
rule CompartmentTypeCanContainCompartments_1
	transform s : source!Shape
	to t : target!CompartmentType 
	extends CompartmentTypeWithAttAndOps {
		guard : s.~features.get("Contains_Compartments")
 		
 		canContainCompartment(s, t);
}

/**
 * This rule transforms a compartment which can contain other compartment types.
 * 
 * This particular rule only transforms compartment when also its attributes and operations
 * are not enabled. This is needed since using the multiple extension 
 * "extends CompartmentTypeWithAttAndOps, CompartmentTypeWithoutAttAndOps" somehow creates a cycle 
 * extension. Thats why there need to be two separate rule for compartment which can contain 
 * other compartment types.
 */
@lazy
rule CompartmentTypeCanContainCompartments_2
	transform s : source!Shape
	to t : target!CompartmentType 
	extends CompartmentTypeWithoutAttAndOps {
		guard : s.~features.get("Contains_Compartments")
 		
 		canContainCompartment(s, t);
}


/**
 * the actions to execute when a compartment can contain other compartments
 */
operation canContainCompartment(s : source!Shape, t : target!CompartmentType) {
	if(not(s.getModel() == null)) {
 		for (elem : source!ModelElement in s.getModel().elements) {	
			//if the children is another compartment type
			if(elem.getType==(source!Type#CompartmentType)) {
				var e = elem.equivalent();
				if(not(e == null)) {
					t.getContains.add(e);
	}	}	}	}
}

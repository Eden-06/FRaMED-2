/**
 * the abstract rule for fulfillments  executes actions done for all fulfillment on the top level and in grouping features
 */
@abstract
rule Fulfillment
	transform s : source!Relation
	to t : Sequence(target!Fulfillment) {
		guard : s.getType()==(source!Type#Fulfillment) // enum value Fulfillment
		
		//create target fulfillments for the source relations
		for(role : source!Shape in s.referencedRoles) {
			var fulfillment = new target!Fulfillment;
			//TODO better
			var tf = true;
			if(s.source.getType == (source!Type#DataType)) { if(not(s.~features.get("Dates"))) { tf = false; }}	
			if(s.source.getType == (source!Type#CompartmentType)) { if(not(s.~features.get("Compartments"))) { tf = false; }}
			if(s.source.getType == (source!Type#RoleType)) { if(not(s.~features.get("Roles"))) { tf = false; }}	
			if(s.target.getType == (source!Type#CompartmentType) and 
			   not(s.target.getContainer().getParent() == null) and
			   s.target.getContainer().getParent().getType() == (source!Type#CompartmentType)) { 
			   if(not(s.~features.get("Contains_Compartments"))) { tf = false; }
			}
			if(tf) {	
				fulfillment.filler ::= s.source;
				fulfillment.filled ::= role;
				t.add(fulfillment);	
		}	}	
}
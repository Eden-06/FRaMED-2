// automatically generated by Xtext
grammar org.framed.iorm.editpolicydsl.Dsl with org.eclipse.xtext.common.Terminals


import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/emf/2003/XMLType" as type
import "http://www.eclipse.org/emf/2002/GenModel" as genmodel


import "http://iorm/1.0"  as iorm
//import "http://iorm.featuremodel/1.0"
import "http://framed/editpolicymodel"


Model returns Model:
	(policies+=Policy (policies+=Policy)*)?;
	
Policy returns Policy:
	override?='override' action=ActionEnum actionType=ActionTypeEnum 
	'{'
		featureRule=FeatureExpression '=>' constraintRule=ConstraintExpression 
	'}';
	
enum ActionEnum returns ActionEnum:
	Add | Reconnect | Create | Start;

enum ActionTypeEnum returns iorm::Type:
	Acyclic | CompartmentType | Cyclic | DataType | Fulfillment | Inheritance | 
	Group | Reflexive | Relationship | RelationshipExclusion | RelationshipImplication | 
	RoleType | RoleEquivalence | RoleGroup | RoleImplication | RoleProhibition|
	Irreflexive;

ConstraintRule returns AbstractRule:
	StepInRule | TrueRule;

FeatureRule returns AbstractRule:
	IsFeatureRule | TrueRule;	

IsFeatureRule returns Rule:
	{Rule}  rule=(IsFeature);

IsFeature returns IsFeature:
	{IsFeature}
	'isFeature';  //(IsFeature.name=>FeatureName);
	
EString returns ecore::EString:
	STRING|ID;

StepInRule returns Rule:
	{Rule} rule=StepIn;
	
StepIn returns IsStepIn:
	{IsStepIn}
	'StepIn';
	
TrueRule returns TrueRule:
	{TrueRule}
	'true';

FalseRule returns FalseRule:
	{FalseRule}
	'false';
	
//expression support for Features
FeatureExpression returns AbstractRule:
	OrFeature;

ImplicationFeature returns AbstractRule:
	OrFeature ({ImplicationRule.leftRule=current} '=>' rightRule=OrFeature)?;

OrFeature returns AbstractRule: 
	AndFeature ({OrRule.rules+=current} '||' rules+=AndFeature)*;

AndFeature returns AbstractRule:
	NotFeatureExpression ({AndRule.rules+=current} '&&' rules+=NotFeatureExpression)*;

NotFeatureExpression returns AbstractRule:
	PrimaryFeature | '!' {NotRule} rule=PrimaryFeature;
  
PrimaryFeature returns AbstractRule:
	FeatureRule | '(' FeatureExpression ')';
	
//expression support for Constraints
ConstraintExpression returns AbstractRule:
	ImplicationConstraint;

ImplicationConstraint returns AbstractRule:
	OrConstraint ({ImplicationRule.leftRule=current} '=>' rightRule=OrConstraint)?;

OrConstraint returns AbstractRule:
	AndConstraint ({OrRule.rules+=current} '||' rules+=AndConstraint)*;

AndConstraint returns AbstractRule:
	NotConstraintExpression ({AndRule.rules+=current} '&&' rules+=NotConstraintExpression)*;

NotConstraintExpression returns AbstractRule:
	PrimaryConstraint | '!' {NotRule} rule=PrimaryConstraint;
  
PrimaryConstraint returns AbstractRule:
	ConstraintRule | '(' ConstraintExpression ')';
	